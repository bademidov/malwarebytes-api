################### Settings ###################

# You can add your Nebula API credentials below to avoid entering it manually every time.
# Note that the credentials will be stored in cleartext, so please make sure that nobody can get access to the script.

$hardcoded_credentials = $false # make sure to set the value to $true of $false
$account_id = "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"
$client_id = "enter_nebula_client_id_here"
$client_secret = "enter_nebula_client_secret_here"

################################################
$baseURI = "https://api.malwarebytes.com"
$authURI = "$baseURI/oauth2/token"

if (-Not $hardcoded_credentials) {
    Write-Host " "
    Write-Host "Please make sure that you have your " -NoNewline
    Write-Host "account ID, client ID" -NoNewline -ForegroundColor Cyan
    Write-Host " and " -NoNewline 
    Write-Host "client secret " -ForegroundColor Cyan -NoNewline 
    Write-Host "in hand to proceed." 
    Write-Host " "
    Write-Host "You can add your credentials at the beginning of the script so that you don't have to enter it manually every time."
    Write-Host " "
    Write-Host "Account ID can be retrieved from a URL after you logged into Nebula console: " -NoNewline
    Write-Host "https://cloud.malwarebytes.com/" -NoNewline
    Write-Host "{account_id}" -ForegroundColor Cyan -NoNewline
    Write-Host "/dashboard"
    Write-Host " "
    Write-Host "Client ID and client secret can be generated by a user (a super-admin role only) in Nebula console at " -NoNewline
    Write-Host "Settings > API & Services." -ForegroundColor Cyan
    Write-Host " "

    $account_id = Read-Host "Enter account ID"
    $client_id = Read-Host "Enter client_id"
    $client_secret = Read-Host "Enter client secret"
}


function Get-AuthToken {
    Write-Host " "
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

    # Scope is a set of privileges for a given credential pair
    # Can be "read" "read write" or "read write execute" depending on what is configured in Nebula console (Settings > API & Services)
    $scope = "read" 
    $credential_pair = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(($client_id, $client_secret -join ":")))

    $headers = @{
        "Authorization" = ("Basic", $credential_pair -join " ");
        "Content-Type" = "application/x-www-form-urlencoded"
    }

    #Write-Host "Base64 encoded credential pair: "
    #Write-Host $credential_pair -ForegroundColor Cyan

    $body = @{
        scope="$scope"
        grant_type="client_credentials"
    }

    Write-Host " "
    try {
        $AuthResult = Invoke-RestMethod -Method POST -Uri $authURI -Body $body -Headers $headers
        #Write-Host "Access token: "
        #Write-Host $AuthResult.access_token -ForegroundColor Cyan
        #Write-Host " "
        #Write-Host "Authentication is successful." -ForegroundColor Green
        Write-Host "Credentials are valid." -ForegroundColor Green
    }
    catch {
        Write-Host "ERROR: Failed to authenticate. Please check you credentials or network connection and try again." -ForegroundColor Red
        return 1
    }

    return $AuthResult.access_token
}

function Get-Endpoints($token) {
    Write-Host " "
    Write-Host "Quering endpoints..."
    $headers = @{
        Authorization = "Bearer $token";
        Accountid = $account_id
    }
    $uri = "$baseURI/nebula/v1/endpoints"
    $body = @{}

    try {
        $response = Invoke-WebRequest -Method POST -Uri $uri -Body $body -Headers $headers
    }
    catch {
        Write-Host $_.Exception.Message -ForegroundColor Red
    }

    $response
}

$token = Get-AuthToken
if ($token -eq 1) {
    exit
}

$json = (Get-Endpoints $token).Content | ConvertFrom-Json
$endpoints = $json.endpoints # unparsed results
$total = $json.total_count
Write-Host "Total endpoints: " -NoNewline
Write-Host $total -ForegroundColor Cyan


# Process results
$results = @()
foreach ($item in $endpoints) {
    # calculate last_scan_days
    if (-Not [string]::IsNullOrEmpty($item.machine.last_scanned_at)) {
        $last_scan_days = (New-TimeSpan -Start (Get-Date $item.machine.last_scanned_at) -End (Get-Date)).Days 
    }
    else {
        $last_scan_days = "Never"
    }

    # calculate last_seen_days
    if (-Not [string]::IsNullOrEmpty($item.machine.last_day_seen)) {
        $last_seen_days = (New-TimeSpan -Start (Get-Date $item.machine.last_day_seen) -End (Get-Date)).Days 
    }
    else {
        $last_seen_days = "Never"
    }

    # set remediation_required status
    if ($item.machine.infection_count -ne 0) {
        $remediation_required = $true
    }
    else {
        $remediation_required = $false
    }

    # set SA_detected status
    if ($item.machine.suspicious_activity_count -ne 0) {
        $sa_detected = $true
    }
    else {
        $sa_detected = $false
    }

    if ($item.machine.reboot_required -ne 0) {
        $reboot_required = $true
    }
    else {
        $reboot_required = $false
    }

    $results += [PSCustomObject]@{
        hostname = $item.agent.fully_qualified_host_name
        online = $item.machine.online
        last_user = $item.agent.last_user
        last_seen_days = $last_seen_days
        #scan_age_days = $item.machine.scan_age_days
        last_scan_days = $last_scan_days
        remediation_required = $remediation_required
        active_threats = $item.machine.infection_count
        reboot_required = $reboot_required
        sa_detected = $sa_detected
        sa_count = $item.machine.suspicious_activity_count
        isolated = $item.machine.isolated
        group_name = $item.machine.group_name
        policy_name = $item.machine.policy_name
        type = $item.agent.os_info.os_type
        os_platform = $item.agent.os_info.os_platform
        os_release_name = $item.agent.os_info.os_release_name
    }
}

# Export results to GridView
$results | Out-GridView

# Export to CSV
$timestamp = Get-date -format "yyyy-MM-dd_HH-mm"
$csvfile = "$PSScriptRoot/endpoints_$timestamp.csv"
try {
    $results | Export-Csv $csvfile -NoTypeInformation -Force
    Write-Host "Results saved to " -NoNewline
    Write-Host $csvfile -ForegroundColor Cyan
}
catch {
    Write-Host $_.Exception.Message -ForegroundColor Red
}

Write-Host " "
Write-Host "Done!" -ForegroundColor Green



